package goq

import (
	"reflect"
)

// CollectorMaker provides methods to create generic collectors.
type CollectorMaker struct{}

func NewMaker() *CollectorMaker {
	return &CollectorMaker{}
}

// ToElem creates an ElemCollector.
// It scans values into a given struct pointer.
func (cm *CollectorMaker) ToElem(ptr interface{}) *ElemCollector {
	return &ElemCollector{
		ptr: ptr,
	}
}

// ToSlice creates a SliceCollector.
// It collects rows into a slice of structs.
//
//	db.Query(q).Collect(z.ToSlice(&items))
func (cm *CollectorMaker) ToSlice(ptr interface{}) *SliceCollector {
	return &SliceCollector{
		ptr: ptr,
	}
}

// MapCollectorMaker creates a MapCollector with the given key column.
//
//	db.Query(q).Collect(z.ToMap(&mapOfStruct).By(z.Users.ID))
//
// Note that the key column specified by 'By' must be scanned into somewhere.
// If you do not collect the key column, use 'ByWith' instead.
// For example, consider this query and structs we will map results to.
//
//	query := z.Select(z.Users.ID, z.Users.GivenName, z.Users.FamilyName).From(z.Users)
//
// structs:
//
//	type names struct {
//		GivenName  string
//		FamilyName string
//	}
//
//	type idAndNames struct {
//		ID         int
//		GivenName  string
//		FamilyName string
//	}
//
// Using 'idAndNames', you can collect results like this:
//
//	var mp map[int]idAndNames
//	db.Query(query).Collect(z.ToMap(&mp).By(z.Users.ID))
//
// But if you use 'names' struct instead, the code below will panic.
//
//	var mp map[int]names
//	db.Query(query).Collect(z.ToMap(&mp).By(z.Users.ID))
//
// This is because the 'z.Users.ID' does not be scanned to any field.
// To collect results without its key field,
// you must provide a pointer for the key by 'ByWith'.
//
//	var mp map[int]names
//	var userIDStore int
//	db.Query(query).Collect(z.ToMap(&mp).ByWith(&userIDStore, z.Users.ID))
type MapCollectorMaker struct {
	collector *MapCollector
}

func (m *MapCollectorMaker) By(key Selectable) *MapCollector {
	m.collector.key = key
	return m.collector
}

func (m *MapCollectorMaker) ByWith(ptr interface{}, key Selectable) *MapCollector {
	m.collector.key = key
	m.collector.keyStore = reflect.ValueOf(ptr).Elem()
	return m.collector
}

// ToMap creates a MapCollector maker.
// To obtain a MapCollector, you need to specify a key using 'By' or 'ByWith'.
//
//	db.Query(q).Collect(z.ToMap(&mapOfStruct).By(z.Users.ID))
//
// See https://godoc.org/github.com/ryym/goq/cllct#MapCollectorMaker for details.
func (cm *CollectorMaker) ToMap(ptr interface{}) *MapCollectorMaker {
	return &MapCollectorMaker{&MapCollector{
		ptr: ptr,
	}}
}

// SliceMapCollectorMaker creates a SliceMapCollector with the given key column.
// Note that the key column specified by 'By' must be scanned into somewhere.
// See https://godoc.org/github.com/ryym/goq/cllct#MapCollectorMaker for details.
type SliceMapCollectorMaker struct {
	collector *SliceMapCollector
}

func (m *SliceMapCollectorMaker) By(key Selectable) *SliceMapCollector {
	m.collector.key = key
	return m.collector
}

func (m *SliceMapCollectorMaker) ByWith(ptr interface{}, key Selectable) *SliceMapCollector {
	m.collector.key = key
	m.collector.keyStore = reflect.ValueOf(ptr).Elem()
	return m.collector
}

// ToSliceMap creates a SliceMapCollectorMaker.
// To obtain a SliceMapCollector, you need to specify a key using 'By' or 'ByWith'.
//
//	db.Query(q).Collect(z.ToSliceMap(&mapOfSlicesOfStruct).By(z.Users.ID))
//
// See https://godoc.org/github.com/ryym/goq/cllct#SliceMapCollectorMaker for details.
func (cm *CollectorMaker) ToSliceMap(ptr interface{}) *SliceMapCollectorMaker {
	return &SliceMapCollectorMaker{&SliceMapCollector{
		ptr: ptr,
	}}
}

// ToRowMap creates a RowMapCollector.
//
//	var row map[string]interface{}
//	db.Query(q).Collect(z.ToRowMap(&row))
func (cm *CollectorMaker) ToRowMap(mp *map[string]interface{}) *RowMapCollector {
	return &RowMapCollector{mp: mp}
}

// ToRowMapSlice creates a RowMapSliceCollector.
//
//	var results []map[string]interface{}
//	db.Query(q).Collect(z.ToRowMapSlice(&results))
func (cm *CollectorMaker) ToRowMapSlice(slice *[]map[string]interface{}) *RowMapSliceCollector {
	return &RowMapSliceCollector{slice: slice}
}

// ModelCollectorMaker provides methods to create model collectors.
// All table helpers generated by Goq embeds this struct.
type ModelCollectorMaker struct {
	structName string
	tableAlias string
	cols       []*Column
}

func NewModelCollectorMaker(cols []*Column, alias string) *ModelCollectorMaker {
	var structName string
	if len(cols) > 0 {
		structName = cols[0].StructName()
	}
	return &ModelCollectorMaker{
		structName: structName,
		tableAlias: alias,
		cols:       cols,
	}
}

// ToElem creates an ModelElemCollector.
// It scans values into a given model pointer.
//
//	db.Query(q).First(z.Users.ToElem(&user))
func (cm *ModelCollectorMaker) ToElem(ptr interface{}) *ModelElemCollector {
	return &ModelElemCollector{
		table: tableInfo{cm.structName, cm.tableAlias},
		ptr:   ptr,
		cols:  cm.cols,
	}
}

// ToSlice creates a ModelSliceCollector.
// It collects rows into a slice of models.
//
//	db.Query(q).Collect(z.Users.ToSlice(&users))
func (cm *ModelCollectorMaker) ToSlice(ptr interface{}) *ModelSliceCollector {
	return &ModelSliceCollector{
		table: tableInfo{cm.structName, cm.tableAlias},
		ptr:   ptr,
		cols:  cm.cols,
	}
}

// ToUniqSlice creates a ModelUniqSliceCollector.
// It collects rows into a slice of models without duplication.
func (cm *ModelCollectorMaker) ToUniqSlice(ptr interface{}) *ModelUniqSliceCollector {
	pkFieldName := ""
	if pkCol := findPKCol(cm.cols); pkCol != nil {
		pkFieldName = pkCol.FieldName()
	}
	return &ModelUniqSliceCollector{
		table:       tableInfo{cm.structName, cm.tableAlias},
		pkFieldName: pkFieldName,
		ptr:         ptr,
		cols:        cm.cols,
	}
}

// ToMap creates a ModelMapCollector.
// It collects rows into a map of models whose key is a primary key.
//
//	db.Query(q).Collect(z.Users.ToMap(&usersMap))
func (cm *ModelCollectorMaker) ToMap(ptr interface{}) *ModelMapCollector {
	mapCllct := &ModelMapCollector{
		table: tableInfo{cm.structName, cm.tableAlias},
		ptr:   ptr,
		cols:  cm.cols,
	}
	if pkCol := findPKCol(cm.cols); pkCol != nil {
		keySel := pkCol.Selection()
		mapCllct.keySel = &keySel
	}
	return mapCllct
}

// ModelSliceMapCollectorMaker creates a ModelSliceMapCollector with the given key column.
// Note that the key column specified by 'By' must be scanned into somewhere.
// See https://godoc.org/github.com/ryym/goq/cllct#MapCollectorMaker for details.
type ModelSliceMapCollectorMaker struct {
	collector *ModelSliceMapCollector
}

func (m *ModelSliceMapCollectorMaker) By(key Selectable) *ModelSliceMapCollector {
	m.collector.key = key
	return m.collector
}

func (m *ModelSliceMapCollectorMaker) ByWith(ptr interface{}, key Selectable) *ModelSliceMapCollector {
	m.collector.key = key
	m.collector.keyStore = reflect.ValueOf(ptr).Elem()
	return m.collector
}

// ToSliceMap creates a ModelSliceMapCollectorMaker.
// To obtain a ModelSliceMapCollector, you need to specify a key using 'By' or 'ByWith'.
//
//	db.Query(q).Collect(z.Cties.ToSliceMap(&mapOfCities).By(z.Cities.CountryID))
//
// See https://godoc.org/github.com/ryym/goq/cllct#ModelSliceMapCollectorMaker for details.
func (cm *ModelCollectorMaker) ToSliceMap(ptr interface{}) *ModelSliceMapCollectorMaker {
	return &ModelSliceMapCollectorMaker{&ModelSliceMapCollector{
		table: tableInfo{cm.structName, cm.tableAlias},
		ptr:   ptr,
		cols:  cm.cols,
	}}
}

// ModelUniqSliceMapCollectorMaker creates a ModelUniqSliceMapCollector with the given key column.
// Note that the key column specified by 'By' must be scanned into somewhere.
// See https://godoc.org/github.com/ryym/goq/cllct#MapCollectorMaker for details.
type ModelUniqSliceMapCollectorMaker struct {
	collector *ModelUniqSliceMapCollector
}

func (m *ModelUniqSliceMapCollectorMaker) By(key Selectable) *ModelUniqSliceMapCollector {
	m.collector.key = key
	return m.collector
}

func (m *ModelUniqSliceMapCollectorMaker) ByWith(ptr interface{}, key Selectable) *ModelUniqSliceMapCollector {
	m.collector.key = key
	m.collector.keyStore = reflect.ValueOf(ptr).Elem()
	return m.collector
}

// ToUniqSliceMap creates a ModelUniqSliceMapCollectorMaker.
// To obtain a ModelUniqSliceMapCollector, you need to specify a key using 'By' or 'ByWith'.
//
//	db.Query(q).Collect(z.Cities.ToUniqSliceMap(&mapOfUniqCities).By(z.Country.Name))
//
// See https://godoc.org/github.com/ryym/goq/cllct#ModelSliceMapCollectorMaker for details.
func (cm *ModelCollectorMaker) ToUniqSliceMap(ptr interface{}) *ModelUniqSliceMapCollectorMaker {
	pkFieldName := ""
	if pkCol := findPKCol(cm.cols); pkCol != nil {
		pkFieldName = pkCol.FieldName()
	}
	return &ModelUniqSliceMapCollectorMaker{&ModelUniqSliceMapCollector{
		table:       tableInfo{cm.structName, cm.tableAlias},
		pkFieldName: pkFieldName,
		ptr:         ptr,
		cols:        cm.cols,
	}}
}

func findPKCol(cols []*Column) *Column {
	for _, col := range cols {
		if meta := col.Meta(); meta.PK {
			return col
		}
	}
	return nil
}
